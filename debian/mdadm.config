#!/bin/sh -eu
# Copyright © 2001-2004 Mario Jou/3en <joussen@debian.org>
# Copyright © 2006 martin f. krafft <madduck@debian.org>
# Distributable under the terms of the GNU GPL version 2.
#
# Revision: $Id$
#

set +u # workaround for #369953
. /usr/share/debconf/confmodule
set -u

CONFIG=/etc/mdadm/mdadm.conf
ALTCONFIG=/etc/mdadm.conf
[ ! -f $CONFIG ] && [ -f $ALTCONFIG ] && CONFIG=$ALTCONFIG 

DEBIANCONFIG=/etc/default/mdadm
DEBIANCONFIG_OLD=/etc/mdadm/debian.conf

if [ ! -e "$DEBIANCONFIG" ]; then
  if [ -e "$DEBIANCONFIG_OLD" ]; then
    DEBIANCONFIG="$DEBIANCONFIG_OLD"
  fi
fi

INITRDSTART=''

if [ -s $DEBIANCONFIG ] ; then
  AUTOSTART=true
  AUTOCHECK=true
  START_DAEMON=true
  MAILADDR=root

  [ -f $DEBIANCONFIG ] && . $DEBIANCONFIG
  if [ -f $CONFIG ]; then
    MAILADDR=$(sed -rne 's,^MAILADDR[[:space:]]*([^[:space:]]+).*,\1,p' $CONFIG)
  fi

  # if $MAIL_TO from $DEBIANCONFIG is set, give it priority. This is because
  # it was used in the command line invocation of the mdadm monitor, and thus
  # overruled any existing setting in /etc/mdadm/mdadm.conf.
  # There's a slight chance of loss of a configuration setting (MAILADDR in
  # /etc/mdadm/mdadm.conf), but it's only an email address, and it is likely
  # unused anyway, thus we run the risk.
  [ -n "${MAIL_TO:-}" ] && MAILADDR="$MAIL_TO"

  [ -n "$AUTOSTART" ] && db_set mdadm/autostart "$AUTOSTART"
  [ -n "$AUTOCHECK" ] && db_set mdadm/autocheck "$AUTOCHECK"
  [ -n "$START_DAEMON" ] && db_set mdadm/start_daemon "$START_DAEMON"
  [ -n "$MAILADDR" ] && db_set mdadm/mail_to "$MAILADDR"
fi

db_input high mdadm/warning || true
db_go

db_fget mdadm/initrdstart seen || true
if [ -z "$INITRDSTART" ] || [ "$RET $INITRDSTART" = "false all" ]; then
  ROOTRAIDDEV="$(df / | sed -rne 's,^(/dev/[^[:space:]]+).*,\1,p')"
  if ! mdadm --detail $ROOTRAIDDEV >/dev/null 2>&1; then
    # you are using some funky setup. Let's be save...
    # (could also happen during preconfigure, when no mdadm present)
    INITRDSTART=all
  else
    INITRDSTART="$ROOTRAIDDEV"
  fi
fi

[ -n "$INITRDSTART" ] && db_set mdadm/initrdstart "$INITRDSTART"

cnt=0
while true; do
  db_input low mdadm/initrdstart || true
  db_go

  db_get mdadm/initrdstart
  INITRDSTART="$(echo $RET | tr , ' ')"

  case "$INITRDSTART" in
    ''|none) INITRDSTART=none; break;;
    all) break;;

    *)
      ARRAYS=''
      ERROR=0
      for i in $INITRDSTART; do

        # standardise by prefixing /dev/
        i="/dev/${i#/dev/}"

        if [ ! -e "$i" ]; then
          echo "E: device node does not exist: $i" >&2
          ERROR=1; break
        fi

        if [ ! -b "$i" ]; then
          echo "E: not a block device: $i" >&2
          ERROR=1; break
        fi

        if ! mdadm --detail "$i" >/dev/null 2>&1; then
          echo "E: not a RAID array: $i" >&2
          ERROR=1; break
        fi
        
        # remove partition from name of partitionable devices
        i="${i%p[0-9]*}"

        # uniquely add device name
        echo $ARRAYS | egrep -q "\b${i}\b" || ARRAYS="${ARRAYS:+$ARRAYS }$i"
      done

      if [ $ERROR -eq 0 ]; then
        INITRDSTART="$ARRAYS"
        # exit the while true loop
        break
      fi

      cnt=$((cnt + 1))
      if [ $cnt -eq 3 ]; then
        echo "W: unable to determine RAID arrays needed for boot." >&2
        echo "W: falling back to starting all of them..." >&2
        INITRDSTART=all
        break
      fi
      ;;
  esac
done

db_set mdadm/initrdstart "$INITRDSTART"

if [ "$INITRDSTART" != all ]; then
  db_input high mdadm/autostart || true
  db_go
fi

db_input medium mdadm/autocheck || true
db_go

db_input medium mdadm/start_daemon || true
db_go

db_get mdadm/start_daemon
if [ "$RET" = true ]; then
  db_input medium mdadm/mail_to || true
  db_go
fi
